config:
  target: "http://localhost:8000"
  http:
    # Give requests a 30 second window before they timeout.
    timeout: 30
  processor: "../helpers.js"
  payload:
    # Load login data for smoke/load environments.
    # Load-testing login data was generated with random data.
    # User records should be created in the DB before running.
    path: "../payloads/{{ $environment }}-logins.csv"
    fields:
      - "username"
      - "password"
      - "email"
    # Select a new user row each time a virtual user logs in.
    order: random
  environments:
    load:
      phases:
        - duration: 1
          arrivalRate: 2
    smoke:
      phases:
        - duration: 1
          arrivalRate: 1
      ensure:
        maxErrorRate: 0
      plugins:
        expect: {}
before:
  name: "Simple login"
  flow:
    - log: "Logging in and retrieving CSRF"
    - get:
        url: "/"
        expect:
          - statusCode: 200
        afterResponse: updateSession
    - get:
        url: "/admin/login/"
        # If csrftoken wasn't set in the previous request, get it now.
        afterResponse: "updateSession"
    - post:
        url: "/accounts/login/"
        formData:
          login: "{{ username }}" 
          password: "{{ password }}"
          csrfmiddlewaretoken: "{{ csrf_token }}"
        expect:
          - statusCode: 302
          - hasHeader: set-cookie
        afterResponse: updateSession
scenarios:
  - flow:
      - log: "Loading initial app count"
      - get:
          # Count initial number of apps
          url: "/api/v1/instances/"
          headers:
            Cookie: "csrftoken={{ csrf_token }}; sessionid={{ session_id }}"
            # X-CSRFToken: "{{ csrf_token }}"
          expect:
            - statusCode: 200
          beforeRequest: disableCookies
          # The way JSONPath is implemented in Artillery makes it essentially useless for all intents and purposes.
          # Instead, have to manually capture and parse it with JS and set the context var.
          afterResponse:
            - updateSession
            - parseInitialApps
      - log: "Getting available apps"
      - get:
          url: "/api/v1/apps/"
          headers:
            Cookie: "sessionid={{ session_id }}; csrftoken={{ csrf_token }}"
            X-CSRFToken: "{{ csrf_token }}"
          expect:
            - statusCode: 200
          capture:
            - json: "$"
              as: available_apps
          beforeRequest:
            - disableCookies
          afterResponse:
            - updateSession
            - getRandomApp
      - log: "Spawning a new app"
      - post:
          # Create a new app
          url: "/api/v1/instances/"
          headers:
            Cookie: "sessionid={{ session_id }}; csrftoken={{ csrf_token }}"
            X-CSRFToken: "{{ csrf_token }}"
          json:
            app_id: "{{ random_app.app_id }}"
            cpus: "{{ random_app.minimum_resources.cpus }}"
            memory: "{{ random_app.minimum_resources.memory }}"
            gpus: "{{ random_app.minimum_resources.gpus }}"
          expect:
            - statusCode: 200
          beforeRequest:
            - disableCookies
          afterResponse: updateSession
      - log: "Confirming new app is created"
      - get:
          url: "/api/v1/instances/"
          expect:
            - statusCode: 200
          afterResponse: parseNewApps
      - get:
          # Basically only way to parse the apps from the request body is manually using JS in the GET /api/v1/instances/ requests.
          # This is because JSONPath implementation is useless (it chooses a random element if the request body returns an array, instead of just the request body array as-is).
          # Since it needs to be parsed in afterResponse, it isn't parsed in time to use expect -> equals in the same request/
          # Thus, it also requires an extra dummy request to be made just to use the expect plugin's functionality properly.
          url: "/"
          expect:
            - equals:
              - "{{ spawned_app.aid }}"
              - "{{ random_app.app_id }}"
          afterResponse: updateSession
      # If we want to give some time for the app to startup.
      # - think: 1
      - log: "Deleting new app"
      - delete:
          url: "/api/v1/instances/{{ spawned_app.sid }}/"
          headers:
            Cookie: "sessionid={{ session_id }}; csrftoken={{ csrf_token }}"
            X-CSRFToken: "{{ csrf_token }}"
          capture:
            - json: "$.status"
              as: "delete_status"
          expect:
            - equals:
              - "{{ delete_status }}"
              - "success"
          beforeRequest: disableCookies
          afterResponse: updateSession
      - log: "Logging out"
      - post:
          url: "/accounts/logout/"
          headers:
            Cookie: "sessionid={{ session_id }}; csrftoken={{ csrf_token }}"
            X-CSRFToken: "{{ csrf_token }}"
          formData:
            csrfmiddlewaretoken: "{{ csrf_token }}"
          expect:
            - statusCode: 302
          beforeRequest: disableCookies